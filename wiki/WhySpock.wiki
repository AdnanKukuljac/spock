#summary Ten reason why Spock is for you.
#labels Featured

  # *Easy to learn*
    If you know Java and JUnit, you are almost ready to go. 
  # *Powered by Groovy*
    Java's dynamic companion lets you do more in less time. Plus, it's a lot of fun! 
  # *Eliminates waste*
    No assertion API. No record/replay mocking API. No superfluous annotations. Everything is questioned, and only the essential is kept.
  # *Detailed information* 
    Spock's runtime collects a wealth of information, and presents it to you when needed.
    {{{
    Condition not satisfied:

    max(a, b) == c
    |   |  |  |  |
    3   1  3  |  2
              false
    }}}
  # *Designed for use*
    We always start from a user's perspective, without worrying about implementation details. Everything else follows from that.
  # *Open-minded*
    Test-first? Test-last? Unit-level? Integration-level? Test-driven? Behavior-driven? We believe there are many ways to create good software, and try to give you the flexibility to do it your way.
  # *Beautiful language*
    Express your thoughts in a beautiful and highly expressive specification language.
    {{{
    def "subscribers receive published messages at least once"() {
      when: publisher.send(msg)
      then: (1.._) * subscriber.receive(msg)
      where: msg << ["load", "save", "reset"]
    }
    }}}
  # *Extensible for everyone*
    @Transaction? @!SpringBean? @!DeployApp? With Spock's interception-based extension mechanism, you can easily create your own extensions.
  # *Compatible with JUnit*
    Run specifications in your IDE, build tool, and continuous integration server. Leverage JUnit's reporting capabilities.
  # *Learns from the history*
    Spock combines the best features of proven tools like JUnit, jMock, and RSpec, and innovates on top of them. 

Learn [SpockBasics more] about Spock, or [GettingStarted get started] right away.