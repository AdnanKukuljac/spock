#summary A look at some of the upcoming features in Spock 0.2.
#labels Featured

== Accessing "Old" Values ==

Inside a `then` block, `old(`_expr_`)` refers to the value of `expr` before the preceding `when` block was entered. Example:

{{{
def "pushing an element on the stack increases its size by one"() {
  def stack = new Stack()
  when: stack.push("element")
  then: stack.size() == old(stack.size()) + 1
}
}}}

== Unrolling Data-Driven Features ==

Sometimes it would be nice if the iterations of a data-driven feature were listed separately in test reports and test runners. This is achieved with the `@Unroll` annotation. Example:

{{{
@Unroll
def "name length"() {
  expect:
  name.size() == length

  where:
  name << ["Kirk", "Spock", "Scotty"]
  length << [4, 5, 6]
}
}}}

Let's have a look at Gradle's test report: TODO

By default, the name of an iteration is the feature's name followed by a consecutive number. This can be changed by providing a naming pattern after `@Unroll`. A naming pattern may refer to data variables by prepending their names with `#`. Example:

{{{
@Unroll("#name should have length #length")
def "name length"() {
  expect:
  name.size() == length

  where:
  name << ["Kirk", "Spock", "Scotty"]
  length << [4, 5, 6]
}
}}}

Here is how this feature is displayed in IntelliJ IDEA: TODO

As we have seen, `@Unroll` changes the way a data-driven feature is represented in test reports and test runners. However, it is important to note that it does _not_ affect its execution semantics.

== Improved Stack Trace Filtering ==

Spock now employs aggressive stack trace filtering to show you only what's relevant. In particular, internals of the test runner's and Groovy's implementation are no longer displayed. Example:

{{{
def "my math is terrible"() {
  expect: oneAndOneMakesThree()
}

void oneAndOneMakesThree() {
  assert 1 + 1 == 3
}
}}}

{{{
Condition not satisfied:

1 + 1 == 3
  |   |
  2   false

  at StackTraceFilteringExample.oneAndOneMakesThree(StackTraceFilteringExample.groovy:19)
  at StackTraceFilteringExample.my math is terrible(StackTraceFilteringExample.groovy:15)
}}}

As you can see, only two lines of the stack trace are displayed. By double-clicking on one of them, you can quickly jump to the corresponding source code line. To see the full stack trace (which is over 50 lines long in this example), set the system property `-Dspock.filterStackTrace=false`.

== Calling void methods from expect and then blocks ==

It is now safe to call void methods from `expect` and `then` blocks, without them being treated as implicit conditions. The following code snippet shows some use cases:

{{{
expect:
println foo // print a message to see what's going on
fooMatchesBar(foo, bar) // condition factored out into void (!) helper method
deepEquals(foo, bar) // call to third-party assertion library
}}}