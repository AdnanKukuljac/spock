#summary Learn how to specify interactions between your objects.

*This article is a stub. You can help Spock by expanding it.*

=== Creating Mocks ===

Mocks can be created for interfaces, non-final Java classes, and non-final Groovy classes (experimental). Currently all mocks are lenient. In other words, if a method call does not match any interaction, the default value for the method's return type is returned.

{{{
def subscriber = Mock(Subscriber) // "dynamic" style (mock name inferred from variable name)

Subscriber subscriber = Mock()    // "static" style" (mock name/type inferred from variable name/type)
}}}

=== Global vs. local interactions ===

Interactions defined outside of a `then` block are called _global_. They are valid from the point of their definition to the end of the feature method.

{{{
setup:
subscriber.isAlive() >> true
}}}

Interactions defined inside of a `then` block are called _local_. They are valid only within the preceding `when` block.

{{{
when: publisher.send(event)
then: 1 * subscriber.receive(event)
}}}

=== Optional vs. required interactions ===

Optional interactions don't have a cardinality, and must have a return value.

{{{
then: subscriber.isAlive() >> true
}}}

Required interactions must have a cardinality, and may have a return value.

{{{
then: 1 * subscriber.isAlive() >> true

then: n * subscriber.receive(event)
}}}

The most commonly used combinations are global+optional (stubbing as part of setup) and local+required (mocking as part of when-block), but the other two combinations are allowed as well.

=== Cardinalities ===

{{{
n * subscriber.receive(event)      // exactly n times

(n.._) * subscriber.receive(event) // at least n times

(_..n) * subscriber.receive(event) // at most n times 
}}}

=== Target constraints ===

{{{
_.receive(event) // receive is called on any mock object
}}}

=== Method constraints ===

{{{
subscriber./set.*/(_) // any setter is called on subscriber (any regular expression allowed)
}}}

=== Argument Constraints ===

{{{
subscriber.receive(_)                      // any argument

subscriber.receive(!null)                  // any non-null argument

subscriber.receive(event)                  // any argument equal to event

subscriber.receive(!event)                 // any argument not equal to event

subscriber.receive(_ as Message)           // any argument that is-a Message (null is not allowed)

subscriber.receive( { it.priority >= 5 } ) // custom constraint
}}}

=== Return Values ===

{{{
subscriber.isAlive() >> true                     // single return value, repeated indefinitely

subscriber.isAlive() >>> [true, false, true]     // multiple return values (anything that Groovy can iterate over), last one repeated indefinitely

def random = new Random()
subscriber.isAlive() >> { random.nextBoolean() } // custom return value

subscriber.isAlive() >> { throw new TimeoutException() } // custom action
}}}

=== Explicit denotation of interactions ===
If an interaction definition in a `then` block depends on other code in the same block, this relationship has to be made explicit as follows:

{{{
then:
interaction {
  def count = 3
  count * suscriber.receive(_)
}
}}}

The same is true for an interaction defined in a helper method:

{{{
then:
interaction {
  subscriberReceivesThreeMessages()
}

...

def subscriberReceivesThreeMessages() {
  3 * subscriber.receive(_)
  // you may define additional interactions here
}
}}}